cmake_minimum_required(VERSION 3.24)

project(onnx-loader)

find_package(AnyDSL_runtime REQUIRED)

include(cmake/onnx-package.cmake)

set(TARGET_NETWORK ${CMAKE_CURRENT_SOURCE_DIR}/mnist-example/mnist_cnn.onnx CACHE STRING "The target network to compile")
set(TARGET_IMAGES ${CMAKE_CURRENT_SOURCE_DIR}/mnist-data/train-images-idx3-ubyte CACHE STRING "The target network to compile")
set(TARGET_LABELS ${CMAKE_CURRENT_SOURCE_DIR}/mnist-data/train-labels-idx1-ubyte CACHE STRING "The target network to compile")

configure_file(src/utils/config.h.in ${CMAKE_BINARY_DIR}/include/config.h @ONLY)
include_directories(${CMAKE_BINARY_DIR}/include)

file(GLOB MAT_OPS src/mat_ops/*.art)

set(SUPPORT_FILES
    ${PROJECT_SOURCE_DIR}/plugin/plugin_interface.art
    ${PROJECT_SOURCE_DIR}/src/utils/read.art
    ${PROJECT_SOURCE_DIR}/src/utils/utils.art
    ${PROJECT_SOURCE_DIR}/src/utils/loop.art
    ${PROJECT_SOURCE_DIR}/src/utils/wmma.art
    ${PROJECT_SOURCE_DIR}/src/utils/convert.art
    ${PROJECT_SOURCE_DIR}/src/sequential.art
    ${PROJECT_SOURCE_DIR}/src/mat.art
    ${MAT_OPS}
)

#Build the base program, run_network kept as an external refference to link against the compiled network.
anydsl_runtime_wrap(MAIN_PROG_JSON
    FRONTEND "artic"
    NAME "main"
    EMIT_JSON
    FILES src/main.art ${SUPPORT_FILES}
)

anydsl_runtime_wrap(MAIN_PROG_JSON_COMPILED
    FRONTEND "anyopt"
    ANYOPT_FLAGS --pass cleanup --pass lower2cff --pass cleanup --keep-intern run_network
    EMIT_JSON
    NAME "main_compiled"
    PLUGINS plugin/load_plugin.cpp
    FILES ${MAIN_PROG_JSON}
)

anydsl_runtime_wrap(NET_TOOLS_JSON
    FRONTEND "artic"
    NAME "network_tools"
    EMIT_JSON
    FILES ${SUPPORT_FILES}
)

#add_custom_command(
#    OUTPUT network.thorin.json
#    COMMAND ${VENV}/bin/python ${CMAKE_CURRENT_SOURCE_DIR}/lib/network.py ${TARGET_NETWORK}
#    DEPENDS lib/network.py ${NET_TOOLS_JSON} ${VENV}
#)
#
##Build the actual network, using the python converter in the process
##We --keep-intern here as well, to trim the code size down.
#anydsl_runtime_wrap(NETWORK_WITHTOOLS_JSON
#    FRONTEND "anyopt"
#    ANYOPT_FLAGS --pass cleanup_fix_point --keep-intern run_network
#    EMIT_JSON
#    NAME "network_withtools"
#    FILES ${CMAKE_CURRENT_BINARY_DIR}/network.thorin.json ${NET_TOOLS_JSON}
#)
#
#anydsl_runtime_wrap(NETWORK_COMPILED_JSON
#    FRONTEND "anyopt"
#    ANYOPT_FLAGS --pass cleanup --pass lower2cff --pass cleanup
#    EMIT_JSON
#    NAME "network_compiled"
#    PLUGINS plugin/load_plugin.cpp
#    FILES ${NETWORK_WITHTOOLS_JSON}
#)
#
##Combine the entire thing to one complete .ll file.
#anydsl_runtime_wrap(MAIN_PROG_OBJ
#    FRONTEND "anyopt"
#    FILES ${MAIN_PROG_JSON_COMPILED} ${NETWORK_COMPILED_JSON}
#)

#This target is generated by anydsl_runtime_wrap, but we need to link it still.
target_link_libraries(load_plugin_TARGET PUBLIC onnx)

add_library(loader_runtime SHARED plugin/load_runtime.cpp)
target_link_libraries(loader_runtime PUBLIC onnx)

#add_executable(main ${MAIN_PROG_OBJ} src/utils/read.cpp src/utils/allocator.cpp)
#target_link_libraries(main loader_runtime ${AnyDSL_runtime_LIBRARIES})

#This target exists to fix cmake dependencies it the tests.
add_custom_target(net-tools-json-target echo "Hello world" DEPENDS ${VENV} ${NET_TOOLS_JSON})


if (BUILD_TESTING)
    include(CTest)
    add_subdirectory(testing)
endif()
