cmake_minimum_required(VERSION 3.24)

project(onnx-loader)

find_package(AnyDSL_runtime REQUIRED)

include(cmake/anydsl-macros.cmake)
include(cmake/onnx-package.cmake)

set(TARGET_NETWORK ${CMAKE_CURRENT_SOURCE_DIR}/mnist-example/mnist_cnn.onnx CACHE STRING "The target network to compile")
set(TARGET_IMAGES ${CMAKE_CURRENT_SOURCE_DIR}/mnist-data/train-images-idx3-ubyte CACHE STRING "The target network to compile")
set(TARGET_LABELS ${CMAKE_CURRENT_SOURCE_DIR}/mnist-data/train-labels-idx1-ubyte CACHE STRING "The target network to compile")

configure_file(utils/config.h.in ${CMAKE_BINARY_DIR}/include/config.h @ONLY)
include_directories(${CMAKE_BINARY_DIR}/include)

file(GLOB MAT_OPS mat_ops/*.art)

#Build the base program, run_network kept as an external refference to link against the compiled network.
anydsl_runtime_fancy_wrap(MAIN_PROG_JSON
    FRONTEND "artic"
    NAME "main"
    EMIT_JSON
    FILES main.art utils/read.art utils/utils.art sequential.art mat.art ${MAT_OPS}
)

anydsl_runtime_fancy_wrap(MAIN_PROG_JSON_COMPILED
    FRONTEND "anyopt"
    ANYOPT_FLAGS --pass cleanup --pass lower2cff --pass cleanup --keep-intern run_network
    EMIT_JSON
    NAME "main_compiled"
    PLUGINS plugin/load_plugin.cpp
    FILES ${MAIN_PROG_JSON}
)

#Build the actual network, using the python converter in the process
#We --keep-intern here as well, to trim the code size down.
anydsl_runtime_fancy_wrap(NET_TOOLS_JSON
    FRONTEND "artic"
    NAME "network_tools"
    EMIT_JSON
    FILES sequential.art mat.art ${MAT_OPS}
)

add_custom_command(
    OUTPUT network.thorin.json
    COMMAND ${VENV}/bin/python ${CMAKE_CURRENT_SOURCE_DIR}/network.py ${TARGET_NETWORK}
    DEPENDS network.py ${NET_TOOLS_JSON} ${VENV}
)

anydsl_runtime_fancy_wrap(NETWORK_WITHTOOLS_JSON
    FRONTEND "anyopt"
    ANYOPT_FLAGS --pass cleanup_fix_point --keep-intern run_network
    EMIT_JSON
    NAME "network_withtools"
    FILES ${CMAKE_CURRENT_BINARY_DIR}/network.thorin.json ${NET_TOOLS_JSON}
)

anydsl_runtime_fancy_wrap(NETWORK_COMPILED_JSON
    FRONTEND "anyopt"
    ANYOPT_FLAGS --pass cleanup --pass lower2cff --pass cleanup
    EMIT_JSON
    NAME "network_compiled"
    PLUGINS plugin/load_plugin.cpp
    FILES ${NETWORK_WITHTOOLS_JSON}
)

#Combine the entire thing to one complete .ll file.
anydsl_runtime_fancy_wrap(MAIN_PROG_OBJ
    FRONTEND "anyopt"
    FILES ${MAIN_PROG_JSON_COMPILED} ${NETWORK_COMPILED_JSON}
)

#This target is generated by anydsl_runtime_fancy_wrap, but we need to link it still.
target_link_libraries(load_plugin_TARGET PUBLIC onnx)

add_library(loader_runtime SHARED plugin/load_runtime.cpp)
target_link_libraries(loader_runtime PUBLIC onnx)

add_executable(main ${MAIN_PROG_OBJ} utils/read.cpp utils/allocator.cpp)
target_link_libraries(main loader_runtime ${AnyDSL_runtime_LIBRARIES})

add_subdirectory(testing)
