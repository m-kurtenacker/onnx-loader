fn @matrix_reshape[T] (manager: PassManager, mat: Tensor3[T], new_shape : (i32, &[i64])) -> Tensor1[T] {
    //let size_fn = @|n : i32| { new_shape.1(n) };
    let new_size = [ new_shape.1(0) ];
    let num_dims = new_shape.0;

    //TODO: This is a direct mapping to memory, but the input tensor shape might actually be different already!
    let new_access_fn = |n : &[i64]| {
        //Build a "linear" address with regards to the new shape.
        let mut address = n(num_dims - 1);
        for i in unroll(0, num_dims - 1) {
            address = address * new_size(num_dims - 2 - i) + n(num_dims - 2 - i);
        }

        //Unpack the address into an addressing vector for the old matrix.
        //let oldworld_address_buffer = manager.alloc_dynamic(0: i64, mat.num_dims as i64);
        //let oldworld_address = bitcast[&mut [i64]](oldworld_address_buffer.data);
        let mut oldworld_address : [i64 * 3];

        for i in unroll(0, 3) {
            let index = address % mat.size(i);
            oldworld_address(i) = index;

            address = address / mat.size(i);
        }

        mat.access_fn(oldworld_address)
    };

    Tensor1[T] {
        buffer = mat.buffer,
        size = new_size,
        access_fn = new_access_fn
    }
}

#[intern]
fn @matrix_reshape_const_f32 (manager: PassManager, mat: Tensor3[f32], new_shape: (i32, &[i64])) -> Tensor1[f32] {
    let output = @matrix_reshape[f32](manager, mat, new_shape);

    //print_tensor("Reshape", output);

    output
}

#[intern]
fn @matrix_reshape_f32 (manager: PassManager, mat: Tensor3[f32], new_shape_tensor: Tensor1[f32]) -> Tensor1[f32] {
    let mut new_shape : (i32, &[i64]);

    new_shape.0 = 1;
    new_shape.1 = [1024];

    let output = @matrix_reshape[f32](manager, mat, new_shape);

    //print_tensor("Reshape", output);

    output
}
