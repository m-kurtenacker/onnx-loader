fn @matrix_transpose[T] (manager: PassManager, mat: Tensor[T], perm: &[i64], output_size: &[i64]) -> Tensor[T] {
    fn @output_size_fn(n : i32) -> i64 { output_size(n) }

    let new_access_fn = |n : &[i64]| {
        let oldworld_address_buffer = manager.alloc_dynamic(0: i64, mat.num_dims as i64);
        let oldworld_address = bitcast[&mut [i64]](oldworld_address_buffer.data);

        for i in unroll(0, mat.num_dims) {
            oldworld_address(perm(i)) = n(i);
        }

        mat.access_fn(oldworld_address)
    };

    Tensor[T] {
        buffer = mat.buffer,
        num_dims = mat.num_dims,
        size_fn = output_size_fn,
        access_fn = new_access_fn
    }
}

#[intern]
fn @matrix_transpose_f32 (manager: PassManager, mat: Tensor[f32], perm: &[i64], output_size: &[i64]) -> Tensor[f32] {
    let output = @matrix_transpose[f32](manager, mat, perm, output_size);

    output
}
